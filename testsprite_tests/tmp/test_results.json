[
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "e1e0ab2d-75b7-4b4f-9597-0d5d3ab6d2d6",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC001-post auth login",
    "description": "Verify user login with valid credentials returns a JWT token and appropriate user role information.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_post_auth_login():\n    login_endpoint = f\"{BASE_URL}/auth/login\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    users = [\n        {\"email\": \"parent@test.com\", \"password\": \"Test@1234\", \"expected_role\": \"parent\"},\n        {\"email\": \"driver@saferide.com\", \"password\": \"Test@1234\", \"expected_role\": \"driver\"}\n    ]\n\n    for user in users:\n        payload = {\n            \"email\": user[\"email\"],\n            \"password\": user[\"password\"]\n        }\n\n        response = requests.post(login_endpoint, json=payload, headers=headers, timeout=TIMEOUT)\n        try:\n            # Validate HTTP status code\n            assert response.status_code == 200, f\"Expected 200 OK for {user['email']}, got {response.status_code}\"\n\n            data = response.json()\n\n            # Validate that access_token is in snake_case\n            assert \"access_token\" in data, f\"'access_token' not found in response for {user['email']}\"\n\n            access_token = data[\"access_token\"]\n            # Basic validation of token type and length (JWT tokens are typically three dot-separated parts)\n            assert isinstance(access_token, str) and len(access_token.split('.')) == 3, \\\n                f\"Invalid JWT token format for {user['email']}\"\n\n            # Check user role information - assuming response contains a 'user' object with 'role' field\n            assert \"user\" in data, f\"User info missing in response for {user['email']}\"\n            user_info = data[\"user\"]\n            assert \"role\" in user_info, f\"User role missing in response for {user['email']}\"\n            # Role should correspond to login used\n            assert user_info[\"role\"].lower() == user[\"expected_role\"], \\\n                f\"User role '{user_info['role']}' does not match expected '{user['expected_role']}' for {user['email']}\"\n        except (AssertionError, KeyError) as e:\n            raise AssertionError(f\"Login test failed for {user['email']}: {e}\")\n\ntest_post_auth_login()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.275Z",
    "modified": "2025-12-16T21:43:00.970Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "414cc09f-b30b-4201-8ac9-41c8bc041b7f",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC002-post auth refresh",
    "description": "Verify token refresh endpoint issues a new valid JWT token when provided a valid refresh token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nPARENT_CREDENTIALS = {\n    \"email\": \"parent@test.com\",\n    \"password\": \"Test@1234\"\n}\n\ndef test_post_auth_refresh():\n    login_url = f\"{BASE_URL}/auth/login\"\n    refresh_url = f\"{BASE_URL}/auth/refresh\"\n\n    # Step 1: Login to get refresh token\n    try:\n        login_resp = requests.post(login_url, json=PARENT_CREDENTIALS, timeout=TIMEOUT)\n        login_resp.raise_for_status()\n        login_data = login_resp.json()\n        refresh_token = login_data.get(\"refresh_token\")\n        assert refresh_token and isinstance(refresh_token, str), \"No refresh_token in login response\"\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Login failed or invalid response: {e}\")\n\n    # Step 2: Use refresh token to get new access token\n    try:\n        refresh_resp = requests.post(refresh_url, json={\"refresh_token\": refresh_token}, timeout=TIMEOUT)\n        refresh_resp.raise_for_status()\n        refresh_data = refresh_resp.json()\n\n        # Validate response content\n        new_access_token = refresh_data.get(\"access_token\")\n        new_refresh_token = refresh_data.get(\"refresh_token\")\n\n        assert new_access_token and isinstance(new_access_token, str), \"No access_token in refresh response\"\n        # Refresh token may or may not be rotated; if returned, validate format\n        if new_refresh_token is not None:\n            assert isinstance(new_refresh_token, str), \"refresh_token returned is not string\"\n\n        # Simple JWT token format check (basic)\n        # JWT tokens typically have 3 parts separated by dots\n        assert new_access_token.count('.') == 2, \"access_token format invalid\"\n\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Token refresh failed or invalid response: {e}\")\n\ntest_post_auth_refresh()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 28, in test_post_auth_refresh\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:3000/auth/refresh\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 47, in <module>\n  File \"<string>\", line 45, in test_post_auth_refresh\nAssertionError: Token refresh failed or invalid response: 400 Client Error: Bad Request for url: http://localhost:3000/auth/refresh\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.282Z",
    "modified": "2025-12-16T21:43:36.433Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "83b0a35a-9dc0-41f2-acda-b80bbf6ef513",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC003-post auth logout",
    "description": "Verify logout endpoint invalidates the current JWT token and prevents further access.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nPARENT_CREDENTIALS = {\n    \"email\": \"parent@test.com\",\n    \"password\": \"Test@1234\"\n}\n\ndef test_post_auth_logout():\n    # Login to get access_token\n    login_resp = requests.post(\n        f\"{BASE_URL}/auth/login\",\n        json={\n            \"email\": PARENT_CREDENTIALS[\"email\"],\n            \"password\": PARENT_CREDENTIALS[\"password\"]\n        },\n        timeout=TIMEOUT\n    )\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    login_data = login_resp.json()\n    access_token = login_data.get(\"access_token\")\n    assert access_token, \"access_token missing in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n\n    # Logout with current token\n    logout_resp = requests.post(\n        f\"{BASE_URL}/auth/logout\",\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert logout_resp.status_code == 200, f\"Logout failed with status {logout_resp.status_code}\"\n\n    # Try to access a protected endpoint after logout to verify token invalidation\n    protected_resp = requests.get(\n        f\"{BASE_URL}/children/parent/me\",  # Using parent endpoint to test authorization\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    # Expect unauthorized or forbidden status\n    assert protected_resp.status_code in (401, 403), f\"Access with logged-out token should be denied, got {protected_resp.status_code}\"\n\ntest_post_auth_logout()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 47, in <module>\n  File \"<string>\", line 45, in test_post_auth_logout\nAssertionError: Access with logged-out token should be denied, got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.288Z",
    "modified": "2025-12-16T21:43:41.742Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "ae07d5db-df3f-4763-b301-fcbc74876578",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC004-post auth forgot password",
    "description": "Verify forgot password endpoint sends a password reset email when a registered email is provided.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nFORGOT_PASSWORD_ENDPOINT = \"/auth/forgot-password\"\nTIMEOUT = 30\n\ndef test_post_auth_forgot_password():\n    url = BASE_URL + FORGOT_PASSWORD_ENDPOINT\n    headers = {\"Content-Type\": \"application/json\"}\n    payload = {\n        \"email\": \"parent@test.com\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        # Expecting 200 OK for successful submission of forgot password request\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        json_response = response.json()\n        # The API response for forgot password may be a message or confirmation\n        assert \"message\" in json_response or \"success\" in json_response, \"Response missing confirmation message\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_post_auth_forgot_password()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.293Z",
    "modified": "2025-12-16T21:43:06.706Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "f71ba20f-291e-46ac-ae36-5b4d909b7a91",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC005-post auth reset password",
    "description": "Verify reset password endpoint successfully updates the user password with a valid reset token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nPARENT_EMAIL = \"parent@test.com\"\nPARENT_PASSWORD = \"Test@1234\"\n\ndef test_post_auth_reset_password():\n    try:\n        # Step 1: Login as parent to get access token\n        login_resp = requests.post(\n            f\"{BASE_URL}/auth/login\",\n            json={\"email\": PARENT_EMAIL, \"password\": PARENT_PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert \"access_token\" in login_data and \"refresh_token\" in login_data, \"Missing tokens in login response\"\n\n        # Step 2: Initiate forgot-password to generate reset token sent to email\n        forgot_resp = requests.post(\n            f\"{BASE_URL}/auth/forgot-password\",\n            json={\"email\": PARENT_EMAIL},\n            timeout=TIMEOUT\n        )\n        # It's assumed this returns 200 even if email is valid and processes sending reset email\n        assert forgot_resp.status_code == 200, f\"Forgot-password failed with status {forgot_resp.status_code}\"\n\n        # Since we cannot actually get the reset token sent via email during test,\n        # we cannot proceed to test reset-password properly with a valid reset_token.\n        # Therefore, we only check that reset-password endpoint with invalid token returns 400.\n\n        reset_token = \"invalid_reset_token_for_test\"\n\n        # Step 3: Use reset-password endpoint with invalid reset token and new password\n        new_password = \"NewTest@1234\"\n        headers = {\"Content-Type\": \"application/json\"}\n        reset_payload = {\n            \"reset_token\": reset_token,\n            \"password\": new_password,\n            \"password_confirm\": new_password\n        }\n        reset_resp = requests.post(\n            f\"{BASE_URL}/auth/reset-password\",\n            json=reset_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n\n        # Validate failure response due to invalid reset token\n        assert reset_resp.status_code == 400, f\"Reset password should fail with status 400 due to invalid token, got {reset_resp.status_code}\"\n        reset_data = reset_resp.json()\n        assert \"message\" in reset_data and isinstance(reset_data[\"message\"], str), \"Expected error message in reset password failure response\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_post_auth_reset_password()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 60, in <module>\n  File \"<string>\", line 54, in test_post_auth_reset_password\nAssertionError: Expected error message in reset password failure response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.299Z",
    "modified": "2025-12-16T21:44:02.433Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "47834cc5-a077-4b42-9062-122c526727b6",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC006-get admin company companyid data isolation",
    "description": "Verify data isolation by ensuring that company-level data is only accessible to authorized users of that company.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nPARENT_CREDENTIALS = {\"email\": \"parent@test.com\", \"password\": \"Test@1234\"}\nDRIVER_CREDENTIALS = {\"email\": \"driver@saferide.com\", \"password\": \"Test@1234\"}\nCOMPANY_ADMIN_CREDENTIALS = {\"email\": \"admin@saferide.com\", \"password\": \"Test@1234\"}\n\ndef login(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    response = requests.post(url, json={\"email\": email, \"password\": password}, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"access_token\" in data, \"No access_token in login response\"\n    return data[\"access_token\"]\n\ndef get_company_id_from_admin(access_token):\n    return 1\n\ndef test_get_admin_company_companyid_data_isolation():\n    parent_token = login(PARENT_CREDENTIALS[\"email\"], PARENT_CREDENTIALS[\"password\"])\n    driver_token = login(DRIVER_CREDENTIALS[\"email\"], DRIVER_CREDENTIALS[\"password\"])\n    admin_token = login(COMPANY_ADMIN_CREDENTIALS[\"email\"], COMPANY_ADMIN_CREDENTIALS[\"password\"])\n\n    company_id = get_company_id_from_admin(admin_token)\n\n    headers_admin = {\"Authorization\": f\"Bearer {admin_token}\"}\n    headers_parent = {\"Authorization\": f\"Bearer {parent_token}\"}\n    headers_driver = {\"Authorization\": f\"Bearer {driver_token}\"}\n\n    url = f\"{BASE_URL}/admin/company/{company_id}\"\n\n    response = requests.get(url, headers=headers_admin, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Admin should access company data, got {response.status_code}\"\n    data = response.json()\n    assert data, \"Admin company data response should not be empty\"\n\n    resp_parent = requests.get(url, headers=headers_parent, timeout=TIMEOUT)\n    assert resp_parent.status_code in (401, 403), (\n        f\"Parent user should NOT access admin company data. Got {resp_parent.status_code}\"\n    )\n\n    resp_driver = requests.get(url, headers=headers_driver, timeout=TIMEOUT)\n    assert resp_driver.status_code in (401, 403), (\n        f\"Driver user should NOT access admin company data. Got {resp_driver.status_code}\"\n    )\n\ntest_get_admin_company_companyid_data_isolation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 35, in test_get_admin_company_companyid_data_isolation\nAssertionError: Admin should access company data, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.304Z",
    "modified": "2025-12-16T21:44:00.521Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "1bd72da5-3316-4b76-9829-b13a75f20238",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC007-post children bulk onboard",
    "description": "Verify bulk onboarding of children with valid data creates multiple child profiles successfully.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nCOMPANY_ADMIN_CREDENTIALS = {\n    \"email\": \"admin@saferide.com\",\n    \"password\": \"Test@1234\"\n}\n\ndef login(email: str, password: str) -> str:\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\"email\": email, \"password\": password}\n    response = requests.post(url, json=payload, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"access_token\" in data, \"Login response missing access_token\"\n    return data[\"access_token\"]\n\ndef bulk_onboard_children(token: str, children_data: list) -> dict:\n    url = f\"{BASE_URL}/children/bulk-onboard\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = requests.post(url, json={\"children\": children_data}, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef delete_child(token: str, child_id: str):\n    url = f\"{BASE_URL}/children/{child_id}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    # Assuming DELETE /children/:id endpoint exists for cleanup\n    # If not provided in PRD, skip deletion\n    response = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    if response.status_code not in (200, 204, 404):\n        response.raise_for_status()\n\ndef test_tc007_post_children_bulk_onboard():\n    token = login(COMPANY_ADMIN_CREDENTIALS[\"email\"], COMPANY_ADMIN_CREDENTIALS[\"password\"])\n\n    children_to_create = [\n        {\n            \"first_name\": \"Alice\",\n            \"last_name\": \"Smith\",\n            \"dob\": \"2015-03-15\",\n            \"gender\": \"female\",\n            \"grade\": 1\n        },\n        {\n            \"first_name\": \"Bob\",\n            \"last_name\": \"Johnson\",\n            \"dob\": \"2014-11-30\",\n            \"gender\": \"male\",\n            \"grade\": 2\n        }\n    ]\n\n    created_child_ids = []\n    response = None\n    try:\n        response = bulk_onboard_children(token, children_to_create)\n        assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}\"\n        data = response.json()\n        assert isinstance(data, dict), \"Response body should be a dict\"\n        assert \"children\" in data, \"Response missing 'children' key\"\n        created_children = data[\"children\"]\n        assert isinstance(created_children, list), \"'children' should be a list\"\n        assert len(created_children) == len(children_to_create), \"Number of created children does not match input\"\n        for original, created in zip(children_to_create, created_children):\n            for key in [\"first_name\", \"last_name\", \"dob\", \"gender\", \"grade\"]:\n                assert created.get(key) == original[key], f\"{key} mismatch in created child\"\n            assert \"id\" in created and isinstance(created[\"id\"], (str, int)), \"Created child missing valid id\"\n            created_child_ids.append(str(created[\"id\"]))\n    finally:\n        # Cleanup created children if API supports deletion\n        for cid in created_child_ids:\n            try:\n                delete_child(token, cid)\n            except Exception:\n                # Log error or ignore cleanup failure\n                pass\n\ntest_tc007_post_children_bulk_onboard()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 59, in test_tc007_post_children_bulk_onboard\nAssertionError: Expected 201 Created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.309Z",
    "modified": "2025-12-16T21:44:20.989Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "651ff18d-8ce9-4742-8b7b-4ef32b6ad6a4",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC008-post children link",
    "description": "Verify linking a child profile with a unique code associates the child correctly to the parent or guardian.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nPARENT_CREDENTIALS = {\"email\": \"parent@test.com\", \"password\": \"Test@1234\"}\nADMIN_CREDENTIALS = {\"email\": \"admin@saferide.com\", \"password\": \"Test@1234\"}\n\nTIMEOUT = 30\n\n\ndef login(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\"email\": email, \"password\": password}\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data and data[\"access_token\"]\n    return data[\"access_token\"]\n\n\ndef create_child(admin_token):\n    url = f\"{BASE_URL}/children/bulk-onboard\"\n    payload = {\n        \"children\": [\n            {\n                \"first_name\": \"TestChildTC008\",\n                \"last_name\": \"LinkTest\",\n                \"dob\": \"2015-04-15\",\n                \"gender\": \"male\"\n            }\n        ]\n    }\n    headers = {\"Authorization\": f\"Bearer {admin_token}\"}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"children\" in data and len(data[\"children\"]) == 1\n    child = data[\"children\"][0]\n    assert \"id\" in child and \"unique_code\" in child\n    return child[\"id\"], child[\"unique_code\"]\n\n\ndef delete_child(child_id, admin_token):\n    pass\n\n\ndef test_post_children_link():\n    parent_token = login(**PARENT_CREDENTIALS)\n    admin_token = login(**ADMIN_CREDENTIALS)\n\n    child_id = None\n    try:\n        child_id, unique_code = create_child(admin_token)\n\n        url_link = f\"{BASE_URL}/children/link\"\n        headers_link = {\"Authorization\": f\"Bearer {parent_token}\"}\n        payload_link = {\"unique_code\": unique_code}\n\n        resp_link = requests.post(url_link, json=payload_link, headers=headers_link, timeout=TIMEOUT)\n        resp_link.raise_for_status()\n        data_link = resp_link.json()\n\n        assert \"child_id\" in data_link and data_link[\"child_id\"] == child_id\n        assert \"parent_id\" in data_link or \"message\" in data_link\n\n    finally:\n        if child_id:\n            delete_child(child_id, admin_token)\n\n\ntest_post_children_link()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 52, in test_post_children_link\n  File \"<string>\", line 34, in create_child\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:3000/children/bulk-onboard\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.314Z",
    "modified": "2025-12-16T21:44:20.988Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "5503d047-729c-4a9b-bd04-2999af8ace0e",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC009-get children",
    "description": "Verify retrieval of children list returns correct profiles filtered by user permissions.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nPARENT_CREDENTIALS = {\n    \"email\": \"parent@test.com\",\n    \"password\": \"Test@1234\"\n}\n\nDRIVER_CREDENTIALS = {\n    \"email\": \"driver@saferide.com\",\n    \"password\": \"Test@1234\"\n}\n\ndef login(credentials):\n    url = f\"{BASE_URL}/auth/login\"\n    resp = requests.post(url, json=credentials, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data and \"refresh_token\" in data\n    return data[\"access_token\"]\n\ndef test_get_children_with_parent_and_driver():\n    # Login as parent\n    parent_token = login(PARENT_CREDENTIALS)\n    parent_headers = {\"Authorization\": f\"Bearer {parent_token}\"}\n    \n    # Login as driver\n    driver_token = login(DRIVER_CREDENTIALS)\n    driver_headers = {\"Authorization\": f\"Bearer {driver_token}\"}\n\n    # Step 1: As parent, get children list via /children/parent/:parentId endpoint\n    # Need to get parentId; assuming API returns user info at /auth/me or in token payload?\n    # Since no /auth/me endpoint documented, assuming token does not include it; \n    # We will try GET /children/parent/:parentId with parentId from /auth/login response or a separate call?\n    # Since no explicit API to get user id, we will attempt to decode parentId from token or else skip dynamic retrieval.\n    # Instead, we try GET /children/parent/{parentId} where parentId extracted from JWT not feasible here.\n    # We can try /children/parent/me endpoint? Not in docs.\n    # We'll attempt a GET /children/parent with parent token to check if returns acceptable response.\n    # According to instructions, parents must query /children/parent/:parentId.\n    # Given no parentId available, we attempt a call to GET /children/parent/:parentEmail replacing @ and . with _ as fallback.\n    \n    # Since extraction of parentId is impossible from given PRD, trying to read from /children/parent/{email} encoded or fallback to 1 for test:\n    import base64\n    # Alternative approach: fetch parent user info via whoami endpoint if exists? Not documented, so fallback:\n    parent_id = \"1\"\n    \n    url_parent_children = f\"{BASE_URL}/children/parent/{parent_id}\"\n    resp_parent = requests.get(url_parent_children, headers=parent_headers, timeout=TIMEOUT)\n\n    # Validate parent access is allowed and response is correct: 200 and returns list of children\n    assert resp_parent.status_code == 200\n    data_parent = resp_parent.json()\n    assert isinstance(data_parent, list)\n    # For each child profile in data_parent ensure it has expected keys and no unauthorized data\n    for child in data_parent:\n        assert \"id\" in child\n        assert \"name\" in child or \"full_name\" in child or \"first_name\" in child or \"last_name\" in child\n        # Permissions: parent sees their children only - no children from other users\n\n    # Step 2: As driver, attempt to GET same endpoint expecting failure due to permission\n    resp_driver = requests.get(url_parent_children, headers=driver_headers, timeout=TIMEOUT)\n    \n    # Driver should be unauthorized or forbidden to get parent-specific children list\n    assert resp_driver.status_code in (401, 403)\n    # Optionally check error message format\n    err_data = resp_driver.json()\n    assert \"error\" in err_data or \"message\" in err_data\n\ntest_get_children_with_parent_and_driver()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.320Z",
    "modified": "2025-12-16T21:43:41.740Z"
  },
  {
    "projectId": "93fb1f89-0408-4d4a-8f32-2db4993b461a",
    "testId": "55a8cde4-dc7b-434e-bea2-219f9cc4efac",
    "userId": "2438c4a8-1071-70b9-9573-27a204d4e3a8",
    "title": "TC010-patch children id",
    "description": "Verify updating child profile information with valid data is successful and changes are persisted.",
    "code": "import requests\nimport base64\nimport json\n\nBASE_URL = \"http://localhost:3000\"\nPARENT_EMAIL = \"parent@test.com\"\nPARENT_PASSWORD = \"Test@1234\"\nTIMEOUT = 30\n\ndef decode_jwt_payload(token):\n    try:\n        payload_part = token.split('.')[1]\n        # Pad base64 string\n        padding_len = 4 - (len(payload_part) % 4)\n        if padding_len != 4:\n            payload_part += '=' * padding_len\n        decoded_bytes = base64.urlsafe_b64decode(payload_part)\n        return json.loads(decoded_bytes)\n    except Exception:\n        return None\n\ndef test_patch_children_id():\n    session = requests.Session()\n    try:\n        # Login as parent to get access_token\n        auth_resp = session.post(\n            f\"{BASE_URL}/auth/login\",\n            json={\"email\": PARENT_EMAIL, \"password\": PARENT_PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert auth_resp.status_code == 200, f\"Login failed: {auth_resp.text}\"\n        auth_data = auth_resp.json()\n        access_token = auth_data.get(\"access_token\")\n        assert access_token, \"access_token not found in login response\"\n        headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n        # Decode JWT token to extract parent ID\n        payload = decode_jwt_payload(access_token)\n        assert payload and \"sub\" in payload, \"JWT payload missing 'sub' field for parent ID\"\n        parent_id = payload[\"sub\"]\n\n        # Get children for this parent to find a child ID to update\n        children_resp = session.get(f\"{BASE_URL}/children/parent/{parent_id}\", headers=headers, timeout=TIMEOUT)\n        assert children_resp.status_code == 200, f\"Failed to get children: {children_resp.text}\"\n        children = children_resp.json()\n        assert isinstance(children, list), \"Children response is not a list\"\n        if len(children) == 0:\n            raise AssertionError(\"No children found for parent to update\")\n\n        child = children[0]\n        child_id = child.get(\"id\")\n        assert child_id, \"Child object missing 'id' field\"\n\n        # Prepare patch data - update child's profile with valid data\n        patch_data = {\n            \"first_name\": child.get(\"first_name\", \"UpdatedFirstName\") + \"_upd\",\n            \"last_name\": child.get(\"last_name\", \"UpdatedLastName\") + \"_upd\",\n            \"nickname\": \"TestNickname\",\n            \"grade\": child.get(\"grade\", 1),\n        }\n\n        patch_resp = session.patch(\n            f\"{BASE_URL}/children/{child_id}\",\n            json=patch_data,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert patch_resp.status_code == 200, f\"Failed to patch child: {patch_resp.text}\"\n        patched_child = patch_resp.json()\n        assert patched_child.get(\"first_name\") == patch_data[\"first_name\"]\n        assert patched_child.get(\"last_name\") == patch_data[\"last_name\"]\n        assert patched_child.get(\"nickname\") == patch_data[\"nickname\"]\n        assert patched_child.get(\"grade\") == patch_data[\"grade\"]\n\n        # Retrieve the child again to verify changes persisted\n        get_resp = session.get(f\"{BASE_URL}/children/parent/{parent_id}\", headers=headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Failed to get children after patch: {get_resp.text}\"\n        updated_children = get_resp.json()\n        updated_child = next((c for c in updated_children if c.get(\"id\") == child_id), None)\n        assert updated_child is not None, \"Updated child not found in children list\"\n        assert updated_child.get(\"first_name\") == patch_data[\"first_name\"]\n        assert updated_child.get(\"last_name\") == patch_data[\"last_name\"]\n        assert updated_child.get(\"nickname\") == patch_data[\"nickname\"]\n        assert updated_child.get(\"grade\") == patch_data[\"grade\"]\n\n    finally:\n        session.close()\n\ntest_patch_children_id()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 89, in <module>\n  File \"<string>\", line 68, in test_patch_children_id\nAssertionError: Failed to patch child: {\"statusCode\":500,\"message\":\"Internal server error\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-16T21:42:39.325Z",
    "modified": "2025-12-16T21:44:20.984Z"
  }
]
